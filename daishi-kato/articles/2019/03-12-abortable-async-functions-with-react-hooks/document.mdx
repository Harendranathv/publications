import { Doc } from '@frontarm/doc'
export const demoboardHelpers = {
  'GitHubSearch.jsx': require('!raw-loader!./demo/GitHubSearch.jsx'),
  'App.jsx': require('!raw-loader!./demo/App.jsx'),
  'index.js': require('!raw-loader!./demo/index.js'),
}

<Doc.AsideTop>

You can't cancel promises in JavaScript and that's one of the reason why libraries such as redux-saga and redux-observables are popular because they allow cancellation. While they are good solutions as well as Redux is, there might be a case when you want just a cancellation mechanism for a promise, not the entire framework. As is noted JavaScript doesn't have cancellation mechanism, but DOM has it. It's called [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController). It's only supported in recent browsers, but polyfills should help for old browsers and Node.js.

----

React Hooks API is a new feature in React 16.8. You can create a custom hook to share logic across components. Hooks are just functions and you can compose them easily. There has been many of proposals for custom hooks, including handling async functions. To my knowledge, there has been no proposal for abortable async functions. If we could use abortable async functions easily with hooks, it would be useful for small use cases where introducing big frameworks (such as redux-saga and redux-observables) is not a good option.

----

In this article, we take a use case to illustrate how it can be implemented in hooks. We don't go deep in the library implementation, rather focus on the usage of it to understand how it is acceptable. The use case is so-called "typeahead search" where you have a textbox in which you can type, and as you type a search query, the search result is shown on the fly. There are three difficulties in this use case; a) we have to deal with async side effect in hooks, b) we need to abort a previous incomplete search which is no longer valid, and c) we want a delay before starting a search to reduce the number of network requests.

</Doc.AsideTop>

## Hooks to handle async functions

Now, let's look into hooks to handle abortable async functions. The first is a hook to create an async task.

```jsx
const task = useAsyncTask(func, deps);
```

`func` is a function with an argument which is AbortController. This function returns a promise, but the function is responsible to cancel the promise by AbortController. It's just a rule of this hook. No magic. `deps` is the dependency list just like the second argument of `useEffect`. This controls when to create an async task. This is surely tricky, but let's assume developers are already used to using the second argument of `useEffect`. The `task` returned by this hook contains information about the state of the task and you can destructure it easily: `const { pending, error, result } = task;`

----

The second hook is to run an async task created by the first hook above.

```jsx
useAsyncRun(task);
```

This starts an async task just once. However, that doesn't mean only one async task will run. As described above, we can control creating async tasks by `deps`, hence eventually it runs several async tasks. The important part of `useAsyncRun` is that it automatically aborts a previous task if it's not yet finished.

----

The core hooks are just the above two, but we want another hook for our use case. The third hook is to combine several async tasks sequentially.

```jsx
const combinedTask = useAsyncCombineSeq(task1, task2);
```

The `combinedTask` returned by this hook contains the information about the state of the combined task, but for result, it should be easier and type-safe to read it from each tasks instead.

----

While `useAsyncTask` is sufficient to create an async task, it's not trivial to write a `func` with the rule that it needs to handle AbortController. Hence, we provide two helper hooks that wrap `useAsyncTask`.

```jsx
const task1 = useAsyncTaskDelay(milliSeconds, deps);
const task2 = useAsyncTaskFetch(url);
```

`useAsyncTaskDelay` is just to wait a certain amount of time.

`useAsyncTaskFetch` is to fetch JSON data from `url`. You can also use "POST" method and fetch non-JSON data with options.


## The use case example

It's time to code and run the use case. We use GitHub repository search. In this use case example, as you type a query string, it will show the search result.

<img alt="Screenshot" src="https://raw.githubusercontent.com/dai-shi/react-hooks-async/master/examples/04_typeahead/screencast.gif" />

Here is the code to realize this example. For the concrete code in TypeScript, visit the [full example](https://github.com/dai-shi/react-hooks-async/tree/master/examples/04_typeahead) in the GitHub repository.

```jsx
const GitHubSearch = ({ query }) => {
  const url = `https://api.github.com/search/repositories?q=${query}`;
  const delayTask = useAsyncTaskDelay(500, [query]);
  const fetchTask = useAsyncTaskFetch(url);
  const combinedTask = useAsyncCombineSeq(delayTask, fetchTask);
  useAsyncRun(combinedTask);
  if (delayTask.pending) return <div>Waiting...</div>;
  if (fetchTask.error) return <Err error={fetchTask.error} />;
  if (fetchTask.pending) return <Loading abort={fetchTask.abort} />;
  return (
    <ul>
      {fetchTask.result.items.map(({ id, name, html_url }) => (
        <li key={id}><a target="_blank" rel="noreferrer noopener" href={html_url}>{name}</a></li>
      ))}
    </ul>
  );
};

const App = () => {
  const [query, setQuery] = useState('');
  return (
    <div>
      Query:<input value={query} onChange={e => setQuery(e.target.value)} />
      {query && <GitHubSearch query={query} />}
    </div>
  );
};
```

Some notes for the code:

1. We use `query &&` in the `App` component. This is to prevent running an async task when `query === ''`.
2. `delayTask.pending` represents the waiting phase of 500ms delay, whereas `fetchTask.pending` represents the networking phase. Unfortunately, we can't distinguish the connecting phase and the transferring phase within the networking phase.
3. You can manually abort the fetch task by pressing a button in `<Loading abort={fetchTask.abort} />`.

Check out how it's working in the demo.

```jsx
//--- GitHubSearch.jsx <-- GitHubSearch.jsx
//--- App.jsx <-- App.jsx
//--- index.js <-- index.js
```

## The library

If you are interested, please check out the library. It's been improved for these few months. It should also work in Concurrent Mode. I would like to hear various feedbacks, including custom hooks design, use cases, implementation issues, and so on. Please drop me a note by Twitter or GitHub issues.

<https://github.com/dai-shi/react-hooks-async>

## Final notes

One of the biggest questions experienced developers might have would be whether we should wait for "Suspense for Data Fetching" in the React roadmap. We are expecting the official "react-cache" in the near future. This will change a lot in data fetching in general.

My answer to it is "No, we can't wait, hooks are so nice that we can't develop without them even if the hook-based data fetching lasts only for a short period." In addition to this emotional answer, I can tell that this library plays a certain role even after we have react-cache. The typeahead example we showed in this article doesn't need caching. There should be other use cases in which caching is not important.
